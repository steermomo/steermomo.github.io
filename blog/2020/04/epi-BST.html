<!DOCTYPE html>
<html lang="en">

<head>
        <meta name="google-site-verification" content="d0pvXqLPH8JyCfWVyhZ7njhGUndRFIR95YM3myMb7rU" />
        <meta charset="utf-8" />
        <meta http-equiv="Cache-Control" content="no-transform" />
        <meta http-equiv="Cache-Control" content="no-siteapp" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=yes" />
        <title>EPI-BST</title>
        <link rel="stylesheet" href="/theme/css/main.css" />

        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
        <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


        <link rel="stylesheet" href="//unpkg.com/heti/umd/heti.min.css">

</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <!-- <h1><a href="/">steer </a></h1> -->
                <nav>
                        <ul>
                                <li><a href="/">ğŸ¦‰</a></li>
                                <li><a href="/blog">Blog</a></li>
                                <li><a href="/archives">Archives</a></li>
                                <li><a href="/gallery">Gallery</a></li>
                                <li id="navName">steer </li>
                        </ul>
                </nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="/blog/2020/04/epi-BST" rel="bookmark" title="Permalink to EPI-BST">EPI-BST</a>
      </h1>
    </header>

    <div class="entry-content">
<div class="post-meta">
        Date: <span >
               2020-04-20 Mon
        </span>
<span>Category: <a href="/category/leetcode/">LeetCode</a></span>
<!-- <p>tags: <a href="/tags/epi/">EPI</a> <a href="/tags/cpp/">cpp</a> </p> -->

</div><!-- /.post-info -->

      <p>å¾ˆä¹…å¾ˆä¹…ä»¥å‰ï¼Œæœ‰äººåˆ·é¢˜ä¸åšè®°å½•ã€‚</p>
<p><img src="/images/what.jfif" style="max-width: 80%"></p>
<p>è¿™é‡Œè®°å½•ä¸€ä¸‹åš<strong>Elements of Programming Interviews</strong>çš„é¢˜ç›®ï¼Œé¿å…å››å¹´ä¹‹åè¿˜æ²¡åˆ·è¿‡BSTã€‚</p>
<p>[TOC]</p>
<h2>BST</h2>
<h3>åº“å‡½æ•°</h3>
<p>C++ä¸­çš„<code>set</code>å’Œ<code>map</code>æ˜¯BST-based.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// ä¸unordered_set å’Œunordered_mapæœ‰äº›ä¸åŒçš„api</span>

<span class="c1">// set</span>
<span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="c1">//è¿”å›çš„è¿­ä»£å™¨æŒ‰keyé€’å¢çš„é¡ºåº</span>
<span class="o">*</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="o">*</span><span class="n">rbegin</span><span class="p">();</span><span class="w"> </span><span class="c1">//è¿”å›BSTä¸­çš„æœ€å¤§æœ€å°å…ƒç´ </span>

<span class="n">lower_bound</span><span class="p">(</span><span class="mi">12</span><span class="p">);</span><span class="o">/</span><span class="n">upper_bound</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"> </span><span class="c1">//è¿”å›ç¬¬ä¸€ä¸ªå¤§äºç­‰äº/å¤§äºå‚æ•°çš„å…ƒç´ </span>

<span class="p">.</span><span class="n">equal_range</span><span class="p">(</span><span class="n">val</span><span class="p">);</span><span class="c1">//</span>
</code></pre></div>

<blockquote>
<h3>equal_range</h3>
<p>The range is defined by two iterators, one pointing to the first element that is <em>not less</em> than <code>key</code> and another pointing to the first element <em>greater</em> than <code>key</code>. Alternatively, the first iterator may be obtained with <a href="dfile:///Users/steer/Library/Application Support/Dash/DocSets/C++/C++.docset/Contents/Resources/Documents/en.cppreference.com/w/cpp/container/set/lower_bound.html">lower_bound()</a>, and the second with <a href="dfile:///Users/steer/Library/Application Support/Dash/DocSets/C++/C++.docset/Contents/Resources/Documents/en.cppreference.com/w/cpp/container/set/upper_bound.html">upper_bound()</a>.</p>
</blockquote>
<h3>TEST IF A BINARY TREE SATISFIES THE BST PROPERTY</h3>
<p>Write a program that takes as input a binary tree and checks if the tree satisfies the BST property .</p>
<p>Hint: Is it correct to check for each node that its key is greater than or equal to the key at its left child and less than or equal to the key at its right child ?</p>
<p>è¦æ£€æŸ¥äºŒå‰æ ‘çš„ç‰¹æ€§ï¼šå·¦å­æ ‘çš„æ‰€æœ‰ç»“ç‚¹å€¼å°äºå½“å‰èŠ‚ç‚¹ã€å³å­æ ‘æ‰€æœ‰ç»“ç‚¹å€¼å¤§äºå½“å‰èŠ‚ç‚¹ã€‚</p>
<div class="highlight"><pre><span></span><code><span class="kt">bool</span><span class="w"> </span><span class="nf">IsBinaryTreeBSTHelper</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">BinaryTreeNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">max_val</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">min_val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">max_val</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">min_val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">IsBinaryTreeBSTHelper</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">min_val</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">IsBinaryTreeBSTHelper</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">max_val</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h3>FIND THE FIRST KEY GREATER THAN A GIVEN VALUE IN A BST</h3>
<p>Write a program that takes as input a BST and a value , and returns the first key that would appear in an inorder traversal which is greater than the input value. For example , when applied to the BST in Figure 15.1 on Page 251 you should return 29 for input 23.</p>
<p>çœ‹å®Œè§£æè§‰å¾—è‡ªå·±å°±æ˜¯ä¸ªå‚»å­ï¼Œå†™äº†ä¸€å¤§å¨åˆ†æƒ…å†µè®¨è®ºã€‚</p>
<p>è¦æ‰¾åˆ°æ¯”kå€¼å¤§çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œä»BSTçš„æ ¹ç»“ç‚¹å‘ä¸‹æœç´¢ï¼šå¦‚æœå½“å‰ç»“ç‚¹å€¼å¤§äºkï¼Œå¯èƒ½æ˜¯å€™é€‰ç‚¹ï¼Œå‘å·¦æœç´¢ï¼›å¦‚æœå½“å‰èŠ‚ç‚¹å°äºkï¼Œåˆ™å‘å³å­æ ‘æœç´¢æ›´å¤§çš„å€¼ã€‚ç›´åˆ°æŠµè¾¾æ ‘çš„å¶ç»“ç‚¹ã€‚</p>
<p>è¯¥æ–¹æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º$O(h)$, ç©ºé—´å¤æ‚åº¦ä¸º$O(1)$</p>
<div class="highlight"><pre><span></span><code><span class="c1">// search_first_greater_value_in_bst.cc</span>
<span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">FindFirstGreaterThanK</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">tree</span><span class="p">,</span>
<span class="w">                                    </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// TODO - you fill in here.</span>

<span class="w">    </span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">sub_tree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tree</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span><span class="w"> </span><span class="o">*</span><span class="n">ret_so_far</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">sub_tree</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sub_tree</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">ret_so_far</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sub_tree</span><span class="p">;</span>
<span class="w">            </span><span class="n">sub_tree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sub_tree</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">sub_tree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sub_tree</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ret_so_far</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3>FIND THE k LARGEST ELEMENTS IN A BST</h3>
<p>A BST is a sorted data structure , which suggests that it should be possible to find the k largest keys easily .</p>
<p>Write a program that takes as input a BST and an integer k , and returns the k largest elements in the BST in decreasing order. </p>
<p>Hint What does an inorder traversal yield ?</p>
<p>brute-forceçš„æ–¹æ³•å°±æ˜¯ä¸­åºéå†ï¼Œè¿”å›æœ€åkä¸ªå…ƒç´ ã€‚è¿™æ ·å‰é¢çš„å…ƒç´ éƒ½ç®—ç™½éå†äº†ï¼Œç›¸åº”åœ°ï¼Œå¯ä»¥ä»åé¢é€†ä¸­åºéå†ã€‚</p>
<div class="highlight"><pre><span></span><code><span class="kt">bool</span><span class="w"> </span><span class="nf">FindKLargestInBSTHelper</span><span class="p">(</span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">sub_tree</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">ret</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sub_tree</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">found</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FindKLargestInBSTHelper</span><span class="p">(</span><span class="n">sub_tree</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// æ‰¾åˆ°å…ƒç´ åç›´æ¥è¿”å›ï¼Œä¸å†éå†å·¦å­æ ‘</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">found</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">ret</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">sub_tree</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">FindKLargestInBSTHelper</span><span class="p">(</span><span class="n">sub_tree</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">FindKLargestInBST</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// TODO - you fill in here.</span>
<span class="w">  </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="w">  </span><span class="n">FindKLargestInBSTHelper</span><span class="p">(</span><span class="n">tree</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3>COMPUTE THE LCA IN A BST</h3>
<p>Since a BST is a specialized binary tree , the notion of lowest common ancestor , as expressed in Problem 10.4 on Page 155 , holds for BSTs too.</p>
<p>In general , computing the LCA of two nodes in a BST is no easier than computing the LCA in a binary tree , since structurally a binary tree can be viewed as a BST where all the keys are equal . However , when the keys are distinct , it is possible to improve on the LCA algorithms for binary trees.</p>
<p>Design an algorithm that takes as input a BST and two nodes , and returns the LCA of the two nodes. For example , for the BST in Figure 15.1 on Page 251 , and nodes C and G , your algorithm should return B . Assume all keys are distinct. Nodes do not have references to their parents .</p>
<p>Hint Take advantage of the BST property .</p>
<p>æ¯”ä¹‹å‰åœ¨äºŒå‰æ ‘ä¸­æŸ¥æ‰¾LCAè¦ç®€å•ä¸€äº›ã€‚ è™½ç„¶ç»“ç‚¹æ²¡æœ‰parentçš„ä¿¡æ¯ï¼Œ å¯¹äºBSTï¼Œåœ¨çŸ¥é“ç»“ç‚¹å€¼çš„æƒ…å†µä¸‹ï¼Œå°±å¯ä»¥ä»ä¸Šå‘ä¸‹æœç´¢åˆ°å¯¹åº”çš„ç»“ç‚¹ã€‚</p>
<p>ä»æ ¹ç»“ç‚¹å¼€å§‹æœç´¢ï¼Œç›´åˆ°æŠµè¾¾LCAï¼Œä»–ä»¬çš„æœç´¢è·¯å¾„éƒ½æ˜¯ä¸€è‡´çš„ï¼Œåœ¨LCAç»“ç‚¹å¼€å§‹å‡ºç°åˆ†æ­§ã€‚</p>
<div class="highlight"><pre><span></span><code><span class="c1">//lowest_common_ancestor_in_bst.cc</span>

<span class="c1">// Input nodes are nonempty and the key at s is less than or equal to that at</span>
<span class="c1">// b.</span>
<span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">FindLca</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">tree</span><span class="p">,</span>
<span class="w">                      </span><span class="k">const</span><span class="w"> </span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">,</span>
<span class="w">                      </span><span class="k">const</span><span class="w"> </span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// TODO - you fill in here.</span>

<span class="w">  </span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tree</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">s_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">b_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="w">  </span><span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">c_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s_val</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">c_val</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">b_val</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">c_val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="c1">// go left</span>
<span class="w">          </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s_val</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">c_val</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">b_val</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">c_val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="c1">// go right</span>
<span class="w">          </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3>RECONSTRUCT A BST FROM TRAVERSAL DATA</h3>
<p>As discussed in Problem 10.12 on Page 163 there are many different binary trees that yield the same sequence of visited nodes in an inorder traversal. This is also true for preorder and postorder traversals. Given the sequence of nodes that an inorder traversal sequence visits and either of the other two traversal sequences , there exists a unique binary tree that yields those sequences . Here we study if it is possible to reconstruct the tree with less traversal information when the tree is known to be a BST.</p>
<p>It is critical that the elements stored in the tree be unique . If the root contains key v and the tree contains more occurrences of v , we cannot always identify from the sequence whether the subsequent vs are in the left subtree or the right subtree. For example , for the tree rooted at G in Figure 15.2 on Page 256 the preorder traversal sequence is 285 , 243 , 285 , 401. The same preorder traversal sequence is seen if 285 appears in the left subtree as the right child of the node with key 243 and 401 is at the root ' s right child .</p>
<p>Suppose you are given the sequence in which keys are visited in an inorder traversal of a BST , and all keys are distinct. Can you reconstruct the BST from the sequence ? If so , write a program to do so. Solve the same problem for preorder and postorder traversal sequences .</p>
<p>å‰åºéå†çš„è¯ï¼Œåºåˆ—çš„ç¬¬ä¸€ä¸ªç»“ç‚¹å°±æ˜¯æ ¹ç»“ç‚¹ï¼Œå‰©ä¸‹çš„å­åºåˆ—å°±æ˜¯å·¦å­æ ‘å’Œå³å­æ ‘ã€‚è€Œåœ¨å‰©ä½™åºåˆ—ä¸­ï¼Œç¬¬ä¸€ä¸ªç»“ç‚¹åˆæ˜¯å·¦å­æ ‘çš„æ ¹ç»“ç‚¹ã€‚</p>
<p>~~å› æ­¤ç›´æ¥æ ¹æ®å‰åºéå†ï¼Œå‘ä¸€é¢—ç©ºçš„BSTä¸­æ’å…¥ç»“ç‚¹å°±å¯ä»¥ã€‚~~  æˆ‘æœ¬æ¥ä»¥ä¸ºè¿™ä¸ªæƒ³æ³•æ˜¯é”™çš„, ä»”ç»†æƒ³äº†ä¸€ä¸‹æ²¡å•¥é—®é¢˜ï¼Œæµ‹è¯•æ ·ä¾‹ä¹Ÿå…¨è¿‡äº†ã€‚ åœ¨æœ€åæƒ…å†µä¸‹(å…¨æ˜¯å·¦å­æ ‘)è¿™ç§æ–¹æ³•çš„æ—¶é—´å¤æ‚åº¦åº”è¯¥ä¸º$O(n^2 )$</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">BstInsert</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// å°†æŒ‡å®šä½ç½®æ’å…¥ç»“ç‚¹</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">root</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span>
<span class="w">                </span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">}</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">BstInsert</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">BstInsert</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">RebuildBSTFromPreorder</span><span class="p">(</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">preorder_sequence</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// TODO - you fill in here.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">preorder_sequence</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span>
<span class="w">          </span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="n">preorder_sequence</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">}</span>
<span class="w">          </span><span class="p">);</span>
<span class="w">  </span><span class="c1">// é¡ºåºæ’å…¥</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">preorder_sequence</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">BstInsert</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="n">preorder_sequence</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">root</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>æœ‰äº†æ ¹ç»“ç‚¹çš„å€¼ï¼Œæ ¹æ®BSTçš„æ€§è´¨ï¼Œå¯ä»¥å°†å‰©ä¸‹çš„å­åºåˆ—åˆ’åˆ†ä¸ºå·¦å­æ ‘å’Œå³å­æ ‘ï¼Œé€’å½’åœ°æ„å»ºå‡ºBSTã€‚</p>
<div class="highlight"><pre><span></span><code><span class="c1">//bst_from_preorder.cc</span>

<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">RebuildBSTFromPreorderHelper</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">preorder_sequence</span><span class="p">,</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">end</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">start</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">end</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// æŸ¥æ‰¾å·¦å³å­æ ‘çš„åˆ’åˆ†ç‚¹</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">transition_point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">transition_point</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">preorder_sequence</span><span class="p">[</span><span class="n">transition_point</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">preorder_sequence</span><span class="p">[</span><span class="n">start</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">++</span><span class="n">transition_point</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// é€’å½’æ„å»ºå­æ ‘</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">       </span><span class="n">preorder_sequence</span><span class="p">[</span><span class="n">start</span><span class="p">],</span>
<span class="w">       </span><span class="n">RebuildBSTFromPreorderHelper</span><span class="p">(</span><span class="n">preorder_sequence</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">transition_point</span><span class="p">),</span>
<span class="w">       </span><span class="n">RebuildBSTFromPreorderHelper</span><span class="p">(</span><span class="n">preorder_sequence</span><span class="p">,</span><span class="w"> </span><span class="n">transition_point</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">)</span>
<span class="w">    </span><span class="p">});</span>
<span class="p">}</span>

<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">RebuildBSTFromPreorder</span><span class="p">(</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">preorder_sequence</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// TODO - you fill in here.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">RebuildBSTFromPreorderHelper</span><span class="p">(</span><span class="n">preorder_sequence</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">preorder_sequence</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div>

<p>ä¸Šè¿°çš„åšæ³•åœ¨æ±‚åˆ†ç•Œç‚¹çš„ç‰‡æ®µä¸­ï¼Œå¯¹vectorè¿›è¡Œäº†å¤šæ¬¡éå†ï¼Œå¦‚æœBSTåªè¦å·¦å­æ ‘ï¼Œå°†è¿›è¡Œå¤§é‡çš„éå†ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º$O(n^2)$ã€‚</p>
<p>åœ¨æœ€å¼€å§‹ä¸å¤ªæ­£ç¡®çš„æ€è·¯è¿˜æ˜¯æä¾›äº†ä¸€äº›ä¿¡æ¯ï¼Œå­åºåˆ—çš„ç¬¬ä¸€ä¸ªå°±æ˜¯å·¦å­æ ‘çš„æ ¹ç»“ç‚¹ã€‚è¿™æ ·å°±æ²¡æœ‰å¿…è¦æ¯æ¬¡éƒ½ä»æ ¹ç»“ç‚¹å¼€å§‹æŸ¥æ‰¾å¹¶æ’å…¥ï¼Œä¾æ¬¡æ„å»ºå·¦å­æ ‘å°±å¯ä»¥äº†å˜›ã€‚</p>
<p>ä¸‹é¢çš„æ–¹æ³•ï¼Œæ¯æ¬¡å°†<code>root_idx</code>å‘å‰æ¨è¿›ä¸€æ¬¡, æ ¹æ®<code>root_idx</code>åˆ›å»ºå½“å‰çš„æ ¹ç»“ç‚¹. æ—¶é—´å¤æ‚åº¦ä¸º$O(n)$</p>
<div class="highlight"><pre><span></span><code><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">RebuildBSTFromPreorderHelper</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">preorder_sequence</span><span class="p">,</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">root_idx</span><span class="p">,</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">low_bound</span><span class="p">,</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">upper_bound</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">root_idx</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">preorder_sequence</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">root_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">preorder_sequence</span><span class="p">[</span><span class="n">root_idx</span><span class="p">];</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">root_val</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">low_bound</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">root_val</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">upper_bound</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="o">++</span><span class="n">root_idx</span><span class="p">;</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">left_subtree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RebuildBSTFromPreorderHelper</span><span class="p">(</span><span class="n">preorder_sequence</span><span class="p">,</span><span class="w"> </span><span class="n">root_idx</span><span class="p">,</span><span class="w"> </span><span class="n">low_bound</span><span class="p">,</span><span class="w"> </span><span class="n">root_val</span><span class="p">);</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">right_subtree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RebuildBSTFromPreorderHelper</span><span class="p">(</span><span class="n">preorder_sequence</span><span class="p">,</span><span class="w"> </span><span class="n">root_idx</span><span class="p">,</span><span class="w"> </span><span class="n">root_val</span><span class="p">,</span><span class="w"> </span><span class="n">upper_bound</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span>
<span class="w">        </span><span class="n">root_val</span><span class="p">,</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">left_subtree</span><span class="p">),</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">right_subtree</span><span class="p">)</span>
<span class="w">    </span><span class="p">});</span>
<span class="p">}</span>

<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">RebuildBSTFromPreorder</span><span class="p">(</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">preorder_sequence</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// TODO - you fill in here.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">root_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">RebuildBSTFromPreorderHelper</span><span class="p">(</span><span class="n">preorder_sequence</span><span class="p">,</span><span class="w"> </span><span class="n">root_idx</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">(),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div>

<h3>Find the closest entries in three sorted arrays</h3>
<p>Design an algorithm that takes three sorted arrays and returns one entry from each such that the minimum interval containing these three entries is as small as possible . For example , if the three arrays are ( 5 , 10 , 15 ) , ( 3 , 6 , 9 , 12 , 15 ) , and ( 8, 16 , 24 ) , then 15 , 15 , 16 lie in the smallest possible interval.</p>
<p>Hint How would you proceed if you needed to pick three entries in a single sorted array ?</p>
<p>æˆ‘è¿é¢˜ç›®éƒ½æ²¡çœ‹æ‡‚... æ²¡ç†è§£é”™çš„è¯ï¼Œæ˜¯è¦åœ¨3ä¸ªæ’åºæ•°ç»„ä¸­åˆ†åˆ«æ‰¾åˆ°3ä¸ªå…ƒç´ ï¼Œä½¿å¾—è¿™3ä¸ªå…ƒç´ ä¹‹é—´çš„é—´è·æœ€å°ã€‚</p>
<p>ä»è¿™3ä¸ªæ•°ç»„çš„å¤´éƒ¨å¼€å§‹ï¼Œåˆå§‹æ—¶è¯»å…¥3ä¸ªå…ƒç´ ï¼Œè®¡ç®—æœ€å¤§æœ€å°å€¼ä¹‹é—´çš„å·®å¼‚ã€‚ç„¶åå°†æœ€å°çš„å…ƒç´ æ›¿æ¢ä¸ºå…¶ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œå†æ¬¡è®¡ç®—æœ€å¤§æœ€å°çš„å·®å¼‚ã€‚</p>
<p>è¿™é‡Œéœ€è¦ä¸åœåœ°æ’å…¥ã€åˆ é™¤ã€æ‰¾åˆ°æœ€å¤§æœ€å°å…ƒç´ ï¼Œæ‰€ä»¥æ¯”è¾ƒé€‚åˆä½¿ç”¨BSTã€‚ï¼ˆè€Œæˆ‘ç¬¬ä¸€æ—¶é—´å±…ç„¶æ˜¯æƒ³åˆ°é€ ä¸€ä¸ªBSTçš„è½®å­ï¼ï¼ï¼ï¼</p>
<p>åœ¨å¤šä¸ªæ’åºæ•°ç»„ä¸­ï¼Œä¼šå‡ºç°ç›¸åŒçš„å…ƒç´ ï¼Œè¿™é‡Œç”¨<code>multimap</code>ä¿æŒè¿­ä»£å™¨ä¿¡æ¯.</p>
<div class="highlight"><pre><span></span><code><span class="c1">//minimum_distance_3_sorted_arrays.cc</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">FindClosestElementsInSortedArrays</span><span class="p">(</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">sorted_arrays</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// TODO - you fill in here.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">min_distance_so_far</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">IterTail</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span><span class="w"> </span><span class="n">iter</span><span class="p">,</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span>
<span class="w">  </span><span class="p">};</span>
<span class="w">  </span><span class="c1">// å­˜åœ¨å¤šä¸ªç›¸åŒå€¼çš„æƒ…å†µï¼Œä½¿ç”¨multimap</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">multimap</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">IterTail</span><span class="o">&gt;</span><span class="w"> </span><span class="n">iter_and_tail</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">sorted_array</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">sorted_arrays</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">iter_and_tail</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">sorted_array</span><span class="p">.</span><span class="n">front</span><span class="p">(),</span>
<span class="w">                              </span><span class="n">IterTail</span><span class="p">{</span><span class="n">cbegin</span><span class="p">(</span><span class="n">sorted_array</span><span class="p">),</span><span class="w"> </span><span class="n">cend</span><span class="p">(</span><span class="n">sorted_array</span><span class="p">)});</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// æ›´æ–°é—´è·</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">min_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter_and_tail</span><span class="p">.</span><span class="n">cbegin</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">max_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter_and_tail</span><span class="p">.</span><span class="n">crbegin</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
<span class="w">      </span><span class="n">min_distance_so_far</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">max_val</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">min_val</span><span class="p">,</span><span class="w"> </span><span class="n">min_distance_so_far</span><span class="p">);</span>
<span class="w">      </span><span class="c1">// æ¨è¿›è¿­ä»£å™¨</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">next_min_iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">next</span><span class="p">(</span><span class="n">cbegin</span><span class="p">(</span><span class="n">iter_and_tail</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">iter</span><span class="p">),</span>
<span class="w">                 </span><span class="n">next_min_end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cbegin</span><span class="p">(</span><span class="n">iter_and_tail</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">tail</span><span class="p">;</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">next_min_iter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">next_min_end</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="n">min_distance_so_far</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="c1">// æ’å…¥æ–°è¿­ä»£å™¨ä½ç½®</span>
<span class="w">      </span><span class="n">iter_and_tail</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span>
<span class="w">              </span><span class="o">*</span><span class="n">next_min_iter</span><span class="p">,</span>
<span class="w">              </span><span class="n">IterTail</span><span class="p">{</span><span class="n">next_min_iter</span><span class="p">,</span><span class="w"> </span><span class="n">next_min_end</span><span class="p">}</span>
<span class="w">              </span><span class="p">);</span>
<span class="w">      </span><span class="c1">// åˆ é™¤æœ€å°å…ƒç´ </span>
<span class="w">      </span><span class="n">iter_and_tail</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">iter_and_tail</span><span class="p">.</span><span class="n">cbegin</span><span class="p">());</span>

<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3>ENUMERATE NUMBERS OF THE FORM a + b $\sqrt{2}$</h3>
<p>Numbers of the form a + b$\sqrt q$ , where a and b are nonnegative integers , and q is an integer which is not the square of another integer , have special properties , e. g . , they are closed under addition and multiplication . Some of the first few numbers of this form are given in Figure 15.4.</p>
<p>Design an algorithm for efficiently computing the k smallest numbers a + b$\sqrt{2}$  for nonnegative integers a and b.</p>
<p>è¦è®¡ç®—å‰kä¸ªç¬¦åˆa + b $\sqrt{2}$çš„æ•°å€¼ã€‚</p>
<p>æš´åŠ›çš„è§£æ³•å°±æ˜¯åˆ†åˆ«è®¡ç®—å‰kä¸ªaå’Œbå¯¹åº”çš„å€¼ï¼Œç„¶åå¯¹$k^2$ä¸ªç»“æœæ’åº. </p>
<p>æ—¶é—´å¤æ‚åº¦æ›´ä½çš„æ–¹æ³•æœ‰äº›ç±»ä¼¼ä¹‹å‰ç”¨å †æ’åºæŸ¥æ‰¾æœ€å°çš„$n$ä¸ªå€¼åšæ³•.   è¿™é‡Œç”¨åˆ°ä¸¤ä¸ªç‰¹æ€§:</p>
<ol>
<li>C++ä¸­çš„setçš„åº•å±‚æ˜¯BST</li>
<li>BSTçš„<code>begin()</code>æ–¹æ³•è¿”å›æœ€å°å…ƒç´ çš„è¿­ä»£å™¨.</li>
</ol>
<p>è¿™æ ·åœ¨æœ€å¼€å§‹æ—¶å‘BSTä¸­æ’å…¥$a$, $b$å‡ä¸º0çš„ç»“ç‚¹, ç„¶åæ¯æ¬¡ä»BSTä¸­å–å‡ºæœ€å°å…ƒç´ , å°†å…¶$a$, $b$å€¼åˆ†åˆ«+1åå†æ’å…¥åˆ°BSTä¸­.</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">ABSqrt2</span><span class="p">{</span>
<span class="w">    </span><span class="n">ABSqrt2</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">a</span><span class="p">),</span><span class="w"> </span><span class="n">b</span><span class="p">(</span><span class="n">b</span><span class="p">),</span><span class="w"> </span><span class="n">val</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)){}</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ABSqrt2</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rhs</span><span class="p">.</span><span class="n">val</span><span class="p">;}</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">GenerateFirstKABSqrt2</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// TODO - you fill in here.</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">ABSqrt2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">candidates</span><span class="p">;</span>
<span class="w">  </span><span class="n">candidates</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">  </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">next_smallest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">candidates</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span>
<span class="w">      </span><span class="n">ret</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">next_smallest</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>

<span class="w">      </span><span class="n">candidates</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">next_smallest</span><span class="o">-&gt;</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">next_smallest</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">);</span>
<span class="w">      </span><span class="n">candidates</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">next_smallest</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">next_smallest</span><span class="o">-&gt;</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

<span class="w">      </span><span class="n">candidates</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">next_smallest</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3>THE MOST VISITED PAGES PROBLEM</h3>
<p>You are given a server log file containing billions of lines. Each line contains a number of fields. For this problem, the relevant field is an id denoting the page that was accessed.
Write a function to read the next line from a log file, and a function to find the k most visited pages, where k is an input to the function. Optimize performance for the situation where calls to the two functions are interleaved. You can assume the set of distinct pages is small enough to fit in RAM.</p>
<h3>BUILDA MINIMUM HEIGHT BST FROM A SORTED ARRAY</h3>
<p>Given a sorted array, the number of BSTs that can be built on the entries in the array grows enormously with its size. Some of these trees are skewed, and are closer to lists; others are more balanced. See Figure 15.3 on Page 259 for an example.
How would you build a BST of minimum possible height from a sorted array?
Hint: Which element should be the root?</p>
<p>è¦æ„å»ºæœ€çŸ®çš„BSTï¼ŒBSTçš„å·¦å³å­æ ‘éœ€è¦å¹³è¡¡ï¼Œ è¿™æ ·æ‰èƒ½é™ä½æ ‘çš„é«˜åº¦ã€‚</p>
<p>è€Œä¸”æ•°ç»„ä¹Ÿå·²ç»æ˜¯æ’åºè¿‡çš„ï¼Œåˆ™æ’åœ¨ä¸­é—´ä½ç½®çš„ç»“ç‚¹ç”¨äºæ„å»ºæ ¹ç»“ç‚¹ã€‚</p>
<p>é€’å½’åœ°å‘ä¸‹æ„å»ºæ ‘</p>
<div class="highlight"><pre><span></span><code><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">BuildMinHeightBSTFromSortedArrayHelper</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">right</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">middle_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">right</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">left</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// é€’å½’æ„å»ºç»“ç‚¹</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="n">A</span><span class="p">[</span><span class="n">middle_idx</span><span class="p">],</span>
<span class="w">                                                       </span><span class="n">BuildMinHeightBSTFromSortedArrayHelper</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">middle_idx</span><span class="p">),</span>
<span class="w">                                                       </span><span class="n">BuildMinHeightBSTFromSortedArrayHelper</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">middle_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">)});</span>
<span class="p">}</span>
</code></pre></div>

<h3>INSERTIONANDDELETIONINABST</h3>
<p>A BST is a dynamic data structureâ€”in particular, if implemented carefully, key inser-tion and deletion can be made very fast.
Design efficient functions for inserting and removing keys in a BST. Assume that all elements in the BST are unique, and that your insertion method must preserve this property.</p>
<h3>TEST IF THREE BST NODES ARE TOTALLY ORDERED</h3>
<p>Write a program which takes two nodes in a BST and a third node, the "middle" node, and determines if one of the two nodes is a proper ancestor and the other a proper descendant of the middle. (A proper ancestor of a node is an ancestor that is not equal to the node; a proper descendant is defined similarly.) For example, in Figure 15.1 on Page 251, if the middle is Node /, your function should return true if the two nodes are {A,K\ or It should return false if the two nodes are {I,P\ or {/, K. You can assume that all keys are unique. Nodes do not have pointers to their parents</p>
<p>ç»™å‡ºBSTä¸­çš„ä¸¤ä¸ªç»“ç‚¹å’Œç¬¬ä¸‰ä¸ªç»“ç‚¹ï¼Œåˆ¤æ–­ç¬¬ä¸‰ä¸ªç»“ç‚¹æ˜¯å¦æ˜¯åˆšå¥½åœ¨å‰ä¸¤ä¸ªç»“ç‚¹ä¸­é—´ï¼ˆåœ¨åŒä¸€æ¡å‘ä¸Šéå†çš„è·¯å¾„å†…ï¼‰ï¼Œ ç»“ç‚¹ä¸åŒ…å«çˆ¶ç»“ç‚¹ä¿¡æ¯ã€‚</p>
<p>å› ä¸ºæ˜¯BSTï¼Œç»“ç‚¹ä¸åŒ…å«çˆ¶ç»“ç‚¹ä¿¡æ¯ä¹Ÿå¯ä»¥å®ç°è·¯å¾„éå†ã€‚</p>
<p>ä»ç¬¬ä¸€ä¸ªç»“ç‚¹æŸ¥æ‰¾è‡³ç¬¬äºŒä¸ªç»“ç‚¹ï¼Œå¦‚æœä¸­é—´æœ‰ç»è¿‡ç¬¬3ä¸ªç»“ç‚¹ï¼Œåˆ™ç¬¬3ä¸ªç»“ç‚¹æ˜¯åœ¨å®ƒä»¬ä¹‹é—´çš„ã€‚</p>
<p>è¿™é‡Œå› ä¸ºå‰ä¸¤ä¸ªç»“ç‚¹å¹¶æ²¡æœ‰ä¿è¯é¡ºåºï¼Œéœ€è¦é€†è½¬å†æŸ¥æ‰¾ä¸€æ¬¡ã€‚</p>
<div class="highlight"><pre><span></span><code><span class="kt">bool</span><span class="w"> </span><span class="nf">IsAncAndDes</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lookup</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ä»head åˆ° tailéå†ä¸€æ¬¡</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lookup</span><span class="p">.</span><span class="n">front</span><span class="p">(),</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lookup</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">c_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">head</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">head</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">lookup</span><span class="p">[</span><span class="n">c_idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="o">++</span><span class="n">c_idx</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">head</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">c_idx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">PairIncludesAncestorAndDescendantOfM</span><span class="p">(</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">possible_anc_or_desc_0</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">possible_anc_or_desc_1</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">middle</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// TODO - you fill in here.</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*&gt;</span><span class="w"> </span><span class="n">lookup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">possible_anc_or_desc_0</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span><span class="w"> </span><span class="n">middle</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span><span class="w"> </span><span class="n">possible_anc_or_desc_1</span><span class="p">.</span><span class="n">get</span><span class="p">()};</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">s_order_ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IsAncAndDes</span><span class="p">(</span><span class="n">lookup</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s_order_ret</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">lookup</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">lookup</span><span class="p">));</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">reverse_order_ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IsAncAndDes</span><span class="p">(</span><span class="n">lookup</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">reverse_order_ret</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3>THE RANGE LOOKUP PROBLEM</h3>
<p>Consider the problem of developing a web-service that takes a geographical loca- tion, and returns the nearest restaurant. The service starts with a set of restaurant locationsâ€”each location includes X and Y-coordinates. A query consists of a location, and should return the nearest restaurant (ties can be broken arbitrarily).</p>
<p>One approach is to build two BSTs on the restaurant locations: Tx sorted on the X coordinates, and Ty sorted on the Y coordinates. A query on location ( p,q) can be performed by finding all the restaurants whose X coordinate is in the interval [ p- D, p+ D], and all the restaurants whose Ycoordinate is in the interval [q- D, q+ D], taking the intersection of these two sets, and finding the restaurant in the intersection which is closest to ( p,q). Heuristically, if D is chosen correctly, the subsets are small and a brute-force search for the closest point is fast. One approach is to start with a small value for D and keep doubling it until the final intersection is nonempty.
There are other data structures which are more robust, e.g., Quadtrees and k-d trees, but the approach outlined above works well in practice.
Write a program that takes as input a BST and an interval and returns the BST keys that lie in the interval. For example, for the tree in Figure 15.1 on Page 251, and interval [16, 31], you should return 17, 19, 23, 29, 31.</p>
<p>å¯¹BSTä¸­åºéå†å¯ä»¥å¾—åˆ°é¡ºåºåºåˆ—ï¼Œåœ¨ä¸­åºéå†çš„è¿‡ç¨‹ä¸­ï¼Œè®¾ç½®æ¡ä»¶è¿›è¡Œå‰ªæï¼Œé™ä½æœç´¢çš„ç©ºé—´ï¼Œç›´æ¥é’ˆå¯¹åŒºé—´è¿›è¡Œæœç´¢ï¼Œ åŒºé—´å†…çš„å€¼éƒ½æ‰¾å®Œåç«‹åˆ»é€€å‡ºæœç´¢ã€‚</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">RangeLookupInBSTHelper</span><span class="p">(</span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Interval</span><span class="o">&amp;</span><span class="w"> </span><span class="n">interval</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">c_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">c_data</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">interval</span><span class="p">.</span><span class="n">left</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">RangeLookupInBSTHelper</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span><span class="w"> </span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="n">interval</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">c_data</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">interval</span><span class="p">.</span><span class="n">left</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">c_data</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">interval</span><span class="p">.</span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">ret</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">c_data</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">c_data</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">interval</span><span class="p">.</span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">RangeLookupInBSTHelper</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span><span class="w"> </span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="n">interval</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="p">}</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">RangeLookupInBST</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">BstNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">tree</span><span class="p">,</span>
<span class="w">                             </span><span class="k">const</span><span class="w"> </span><span class="n">Interval</span><span class="o">&amp;</span><span class="w"> </span><span class="n">interval</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// TODO - you fill in here.</span>
<span class="w">  </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="w">  </span><span class="n">RangeLookupInBSTHelper</span><span class="p">(</span><span class="n">tree</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span><span class="w"> </span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="n">interval</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h2>Augmented BSTs</h2>
<h3>ADD CREDITS</h3>
<p>Consider a server that a large number of clients connect to. Each client is identified by a string. Each client has a "credit", which is a nonnegative integer value. The server needs to maintain a data structure to which clients can be added, removed, queried, or updated. In addition, the server needs to be able to add a specified number of credits to all clients simultaneously.</p>
<p>Design a data structure that implements the following methods:</p>
<ul>
<li>Insert</li>
<li>Remove</li>
<li>Lookup</li>
<li>Add-to-all</li>
<li>Max</li>
</ul>
    </div><!-- /.entry-content -->


  </article>


</section>

<div id="comments">
  <h2 style="margin-top: 0.1rem;">Comments !</h2>
  <div id="gitalk-container"></div>
</div>
<script>
  var gitalk = new Gitalk({
    clientID: '4dfbf5aad180623dc634',
    clientSecret: '4c7167883746062103d9dbc2ec8b1ddfd6780d58',
    repo: 'steermomo.github.io',
    owner: 'steermomo',
    admin: ['steermomo'],
    id: location.pathname,      // Ensure uniqueness and length less than 50
    distractionFreeMode: false,  // Facebook-like distraction free mode
    createIssueManually: true,
  })
  gitalk.render('gitalk-container')
</script>
        <section id="extras" class="body">
        </section><!-- /#extras -->
<footer id="contentinfo" class="body">
  <address id="about" class="vcard body">
    Copyright Â© 2024
    </br>
    Proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a
      href="http://python.org">Python</a>.
  </address>

  <!-- /#about -->


</footer><!-- /#contentinfo -->



</body>

</html>