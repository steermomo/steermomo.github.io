<!DOCTYPE html>
<html lang="en">

<head>
        <meta name="google-site-verification" content="d0pvXqLPH8JyCfWVyhZ7njhGUndRFIR95YM3myMb7rU" />
        <meta charset="utf-8" />
        <meta http-equiv="Cache-Control" content="no-transform" />
        <meta http-equiv="Cache-Control" content="no-siteapp" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=yes" />
        <title>EPI-Hash Tables</title>
        <link rel="stylesheet" href="/theme/css/main.css" />

        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
        <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


        <link rel="stylesheet" href="//unpkg.com/heti/umd/heti.min.css">

</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <!-- <h1><a href="/">steer </a></h1> -->
                <nav>
                        <ul>
                                <li><a href="/">ğŸ¦‰</a></li>
                                <li><a href="/blog">Blog</a></li>
                                <li><a href="/archives">Archives</a></li>
                                <li><a href="/gallery">Gallery</a></li>
                                <li id="navName">steer </li>
                        </ul>
                </nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="/blog/2020/04/epi-Hash-Tables" rel="bookmark" title="Permalink to EPI-Hash Tables">EPI-Hash Tables</a>
      </h1>
    </header>

    <div class="entry-content">
<div class="post-meta">
        Date: <span >
               2020-04-17 Fri
        </span>
<span>Category: <a href="/category/leetcode/">LeetCode</a></span>
<!-- <p>tags: <a href="/tags/epi/">EPI</a> <a href="/tags/cpp/">cpp</a> </p> -->

</div><!-- /.post-info -->

      <p>å¾ˆä¹…å¾ˆä¹…ä»¥å‰ï¼Œæœ‰äººåˆ·é¢˜ä¸åšè®°å½•ï¼Œæ²¡åˆ·è¿‡Hash Tablesã€‚</p>
<p><img src="/images/what.jfif" style="max-width: 80%"></p>
<p>è¿™é‡Œè®°å½•ä¸€ä¸‹åš<strong>Elements of Programming Interviews</strong>çš„é¢˜ç›®ï¼Œé¿å…å››å¹´ä¹‹åè¿˜æ²¡åˆ·è¿‡Hash Tablesã€‚</p>
<p>[TOC]</p>
<h2>Hash Tables</h2>
<h3>Boot camp</h3>
<p>ä¸¤ä¸ªä¾‹å­ï¼šå“ˆå¸Œè¡¨çš„åº”ç”¨ï¼Œå“ˆå¸Œè¡¨classçš„è®¾è®¡</p>
<h4>An application of hash tables</h4>
<p>åˆ¤æ–­Anagrams</p>
<h4>Design of a hashable class</h4>
<p>å‡è®¾æœ‰è¡¨ç¤ºè”ç»œäººçš„<code>class</code>ï¼Œè¢«å­˜å‚¨åœ¨åºåˆ—ä¸­ã€‚ä¸ºäº†ç®€å•èµ·è§ï¼Œæ¯ä¸ªè”ç»œäººçš„ä¿¡æ¯åªåŒ…å«ä¸€ç³»åˆ—stringï¼ŒåŒ…å«ç›¸åŒçš„string setçš„è”ç»œäººè¢«è§†ä¸ºåŒä¸€ä¸ªé¡¹ç›®ã€‚</p>
<p>è®¾è®¡ä¸€ä¸ªhash function åˆå¹¶é‡å¤çš„è”ç»œäººä¿¡æ¯ã€‚</p>
<p>ä¸‹é¢ç”¨åˆ°äº†ä¸¤ä¸ªæœªäº†è§£è¿‡çš„çŸ¥è¯†ï¼š</p>
<blockquote>
<h3>std::hash</h3>
<p><code>c++
template&lt; class Key &gt;
struct hash</code></p>
<p>The <em>enabled</em> specializations of the (since C++17) hash template defines a function object that implements a <a href="https://en.wikipedia.org/wiki/Hash_function">hash function</a>. Instances of this function object satisfy <a href="dfile:///Users/steer/Library/Application Support/Dash/DocSets/C++/C++.docset/Contents/Resources/Documents/en.cppreference.com/w/cpp/named_req/Hash.html"><em>Hash</em></a>. In particular, they define an operator() const that:</p>
<ol>
<li>
<p>Accepts a single parameter of type <code>Key</code>.</p>
</li>
<li>
<p>Returns a value of type <a href="dfile:///Users/steer/Library/Application Support/Dash/DocSets/C++/C++.docset/Contents/Resources/Documents/en.cppreference.com/w/cpp/types/size_t.html">std::size_t</a> that represents the hash value of the parameter.</p>
</li>
<li>
<p>Does not throw exceptions when called.</p>
</li>
<li>
<p>For two parameters <code>k1</code> and <code>k2</code> that are equal, std::hash<Key>()(k1) == std::hash<Key>()(k2).</p>
</li>
<li>
<p>For two different parameters <code>k1</code> and <code>k2</code> that are not equal, the probability that std::hash<Key>()(k1) == std::hash<Key>()(k2) should be very small, approaching 1.0/<a href="dfile:///Users/steer/Library/Application Support/Dash/DocSets/C++/C++.docset/Contents/Resources/Documents/en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits</a>&lt;<a href="dfile:///Users/steer/Library/Application Support/Dash/DocSets/C++/C++.docset/Contents/Resources/Documents/en.cppreference.com/w/cpp/types/size_t.html">std::size_t</a>&gt;::max().</p>
</li>
</ol>
</blockquote>
<p>unordered_set ç¬¬äºŒä¸ªkey_wordæŒ‡å®šæ‰€ç”¨çš„hashå‡½æ•°ã€‚</p>
<blockquote>
<h3>std::unordered_set</h3>
<p>```c++
template&lt;
    class Key,
    class Hash = std::hash<Key>,
    class KeyEqual = std::equal_to<Key>,
    class Allocator = std::allocator<Key></p>
<blockquote>
<p>class unordered_set;
```</p>
</blockquote>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">ContactList</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ContactList</span><span class="o">&amp;</span><span class="w"> </span><span class="n">that</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">names</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">names</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">names</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">that</span><span class="p">.</span><span class="n">names</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">HashContactList</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">operator</span><span class="p">()(</span><span class="k">const</span><span class="w"> </span><span class="n">ContactList</span><span class="o">&amp;</span><span class="w"> </span><span class="n">contacts</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">hash_code</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">contracts</span><span class="p">.</span><span class="n">names</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">contracts</span><span class="p">.</span><span class="n">names</span><span class="p">.</span><span class="n">end</span><span class="p">()))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">hash_code</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">hash</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">name</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">ContactList</span><span class="o">&gt;</span><span class="w"> </span><span class="n">MergeContractLists</span><span class="p">(</span><span class="n">cont</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ContactList</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">contracts</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">ContactList</span><span class="p">,</span><span class="w"> </span><span class="n">HashContractList</span><span class="o">&gt;</span><span class="w"> </span><span class="n">unique_contracts</span><span class="p">(</span><span class="n">contracts</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">contracts</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="n">unique_contracts</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">unique_contracts</span><span class="p">.</span><span class="n">end</span><span class="p">()};</span>
<span class="p">}</span>
</code></pre></div>

<h3>åº“å‡½æ•°</h3>
<p>hash table</p>
<div class="highlight"><pre><span></span><code><span class="c1">// éƒ½ä¸å…è®¸é”®é‡å¤</span>
<span class="c1">// unordered_set å­˜å‚¨k</span>
<span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">val</span><span class="p">);</span><span class="w">  </span><span class="c1">//return a pair of iterator and boolean denoting whether the insertion took place.</span>
<span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">val</span><span class="p">);</span><span class="w"> </span><span class="c1">// </span>
<span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">val</span><span class="p">);</span><span class="w"> </span><span class="c1">// return iterator or end()</span>
<span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
<span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">val</span><span class="p">);</span><span class="w"> </span><span class="c1">//c++20</span>

<span class="c1">// unordered_map å­˜å‚¨k-v</span>

<span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">});</span>
<span class="p">.</span><span class="n">emplace</span><span class="p">({</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">});</span>
<span class="p">.</span><span class="n">earse</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
<span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
<span class="p">.</span><span class="n">size</span><span class="p">();</span>


<span class="c1">// functional header</span>
<span class="n">hash</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">val</span><span class="p">);</span>
<span class="c1">//int, bool, string, unique_ptr, shared_ptr, etc.</span>
</code></pre></div>

<h3>FindAnagrams</h3>
<div class="highlight"><pre><span></span><code><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">FindAnagrams</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">dictionary</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// TODO - you fill in here.</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">sorted_string_to_anagrams</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="o">:</span><span class="w"> </span><span class="n">dictionary</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">string</span><span class="w"> </span><span class="nf">sorted_s</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">sorted_s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">sorted_s</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="w">      </span><span class="n">sorted_string_to_anagrams</span><span class="p">[</span><span class="n">sorted_s</span><span class="p">].</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p</span><span class="o">:</span><span class="w"> </span><span class="n">sorted_string_to_anagrams</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">ret</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3>Test for palindromic permutations</h3>
<p>æµ‹è¯•ä¸€ä¸ªå­—ç¬¦ä¸²èƒ½å¦permuteæˆå›æ–‡å­—ç¬¦ä¸²ã€‚</p>
<p>A palindrome is a string that reads the same forwards and backwards, e.g., "level", "rotator", and "foobaraboof".</p>
<p>Write a program to test whether the letters forming a string can be permuted to form a palindrome. For example, "edified" can be permuted to form "deified".</p>
<p>ç›´æ¥å¯¹å­—æ¯è®¡æ•°å°±å¯ä»¥( éš¾ä»¥æƒ³è±¡ä¹‹å‰ä¸å¤ªä¼šç”¨C++çš„counter)</p>
<div class="highlight"><pre><span></span><code><span class="kt">bool</span><span class="w"> </span><span class="nf">CanFormPalindrome</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// TODO - you fill in here.</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cnt</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ch</span><span class="o">:</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="o">++</span><span class="n">cnt</span><span class="p">[</span><span class="n">ch</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">odd_cnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p</span><span class="o">:</span><span class="w"> </span><span class="n">cnt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="o">++</span><span class="n">odd_cnt</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">odd_cnt</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3>Is an anonymous letter constructible?</h3>
<p>Write a program which takes text for an anonymous letter and text for a magazine and determines if it is possible to write the anonymous letter using the magazine. The anonymous letter can be written using the magazine if for each character in the anonymous letter, the number of times it appears in the anonymous letter is no more than the number of times it appears in the magazine.</p>
<p>ä¹Ÿæ˜¯è®¡æ•°åç›¸å‡ã€‚</p>
<div class="highlight"><pre><span></span><code><span class="kt">bool</span><span class="w"> </span><span class="nf">IsLetterConstructibleFromMagazine</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">letter_text</span><span class="p">,</span>
<span class="w">                                       </span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">magazine_text</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// TODO - you fill in here.</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cnt</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ch</span><span class="o">:</span><span class="w"> </span><span class="n">magazine_text</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="o">++</span><span class="n">cnt</span><span class="p">[</span><span class="n">ch</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ch</span><span class="o">:</span><span class="w"> </span><span class="n">letter_text</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cnt</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">cnt</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="o">--</span><span class="n">cnt</span><span class="p">[</span><span class="n">ch</span><span class="p">];</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cnt</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>...å¤ªå¤©çœŸï¼Œä¸Šé¢çš„åšæ³•è™½ç„¶æ˜¯å¯¹çš„ï¼Œä½†æ˜¯æ—¶é—´å¤æ‚åº¦ä¼šé«˜ä¸€äº›ã€‚å¦‚æœmagazine_textçš„å†…å®¹å¾ˆé•¿ï¼Œç¬¬ä¸€æ¬¡éå†ä¼šæ¶ˆè€—å¾ˆå¤šæ—¶é—´ã€‚æ”¹ä¸ºå…ˆæ‰«æletter_textï¼Œ è¿™æ ·å°±ä¸ç”¨å°†magazine_textçš„å†…å®¹ä¹Ÿå…¨éƒ¨è¿‡ä¸€éã€‚</p>
<div class="highlight"><pre><span></span><code><span class="kt">bool</span><span class="w"> </span><span class="nf">IsLetterConstructibleFromMagazine</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">letter_text</span><span class="p">,</span>
<span class="w">                                       </span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">magazine_text</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// TODO - you fill in here.</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cnt</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ch</span><span class="o">:</span><span class="w"> </span><span class="n">letter_text</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="o">++</span><span class="n">cnt</span><span class="p">[</span><span class="n">ch</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ch</span><span class="o">:</span><span class="w"> </span><span class="n">magazine_text</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cnt</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iter</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">cnt</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="o">--</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="n">cnt</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
<span class="w">              </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cnt</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">                  </span><span class="k">break</span><span class="p">;</span>
<span class="w">              </span><span class="p">}</span>
<span class="w">          </span><span class="p">}</span>

<span class="w">      </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">cnt</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<h3>Implement an ISBN cache</h3>
<p>The International Standard Book Number (ISBN) is a unique commercial book iden- tifier. It is a string of length 10. The first 9 characters are digits; the last character is a check character. The check character is the sum of the first 9 digits, modulo 11, with 10 represented by 'X'. (Modern ISBNs use 13 digits, and the check digit is taken modulo 10; this problem is concerned with 10-digit ISBNs.)</p>
<p>Create a cache for looking up prices of books identified by their ISBN. You implement lookup, insert, and remove methods. Use the Least Recently Used (LRU) policy for cache eviction. If an ISBN is already present, insert should not change the price, but it should update that entry to be the most recently used entry. Lookup should also update that entry to be the most recently used entry.</p>
<p>Hint: Amortize the cost of deletion. Alternatively, use an auxiliary data structure.</p>
<p>è¿™ä¸ªæ²¡çœ‹æ‡‚Lookupè·ŸLRUä»€ä¹ˆå…³ç³»ã€‚</p>
<p>çœ‹äº†è§£æä¹‹åæ‰æ˜ç™½è¿™ä¸ªæ˜¯è¦å¹²ä»€ä¹ˆï¼šç¼“å­˜çš„å¤§å°æ˜¯å›ºå®šçš„ï¼Œå½“æ’å…¥çš„æ•°é‡å¤§äºç¼“å­˜çš„å¤§å°æ—¶ï¼Œæ ¹æ®ç¼“å­˜ç­–ç•¥å‰”é™¤ä¸€ä¸ªå…ƒç´ ã€‚</p>
<p>ä½¿ç”¨listç»´æŠ¤LRUé˜Ÿåˆ—ï¼Œlistå­˜å‚¨isbnä¿¡æ¯ã€‚listèƒ½å¤Ÿæ»¡è¶³å¿«é€Ÿåœ°åˆ é™¤ï¼Œå¤´å°¾æ’å…¥ã€‚åŒæ—¶ä½¿ç”¨hashtableè®°å½•isbnåœ¨é˜Ÿåˆ—ä¸­çš„ä½ç½®åŠpriceï¼Œé¿å…å¯¹listçš„é¡ºåºæŸ¥æ‰¾ã€‚</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unordered_map&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;list&gt;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">LruCache</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">LruCache</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">capacity</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">capacity</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">Lookup</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">isbn</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// TODO - you fill in here.</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">isbn_price_table_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">isbn</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">isbn_price_table_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ret_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<span class="w">    </span><span class="n">MoveFront</span><span class="p">(</span><span class="n">isbn</span><span class="p">,</span><span class="w"> </span><span class="n">iter</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ret_val</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">Insert</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">isbn</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">price</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// TODO - you fill in here.</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">isbn_price_table_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">isbn</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">isbn_price_table_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// æœªæ‰¾åˆ°</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isbn_price_table_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">capacity</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// éœ€è¦æ›¿æ¢ä¸€ä¸ªå‡ºå»</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">subs_isbn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lru_queue_</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
<span class="w">            </span><span class="n">isbn_price_table_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">subs_isbn</span><span class="p">);</span>
<span class="w">            </span><span class="n">lru_queue_</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>

<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">lru_queue_</span><span class="p">.</span><span class="n">emplace_front</span><span class="p">(</span><span class="n">isbn</span><span class="p">);</span>
<span class="w">        </span><span class="n">isbn_price_table_</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="n">isbn</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">lru_queue_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">price</span><span class="p">}});</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">MoveFront</span><span class="p">(</span><span class="n">isbn</span><span class="p">,</span><span class="w"> </span><span class="n">iter</span><span class="p">);</span><span class="w"> </span><span class="c1">//æ‰¾åˆ°é¡¹ç›®ï¼Œæ›´æ–°lru</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">Erase</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">isbn</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// TODO - you fill in here.</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">isbn_price_table_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">isbn</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">isbn_price_table_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">lru_queue_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
<span class="w">    </span><span class="n">isbn_price_table_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">Table</span><span class="p">;</span>
<span class="w">    </span><span class="n">Table</span><span class="w"> </span><span class="n">isbn_price_table_</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lru_queue_</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">capacity</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">MoveFront</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">isbn</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Table</span><span class="o">::</span><span class="n">iterator</span><span class="o">&amp;</span><span class="w"> </span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">lru_queue_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
<span class="w">        </span><span class="n">lru_queue_</span><span class="p">.</span><span class="n">emplace_front</span><span class="p">(</span><span class="n">isbn</span><span class="p">);</span>
<span class="w">        </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lru_queue_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h3>Compute the LCA, optimizing for close ancestors</h3>
<p>Problem 10.4 on Page 155 is concerned with computing the LCA in a binary tree with parent pointers in time proportional to the height of the tree. The algorithm presented in Solution 10.4 on Page 155 entails traversing all the way to the root even if the nodes whose LCA is being computed are very close to their LCA.</p>
<p>Design an algorithm for computing the LCA of two nodes in a binary tree. The algorithm's time complexity should depend only on the distance from the nodes to the LCA.</p>
<p>Hint: Focus on the extreme case described in the problem introduction.</p>
<p>ä¹‹å‰æœ‰ä¸ªè®¡ç®—LCAçš„é¢˜ç›®ï¼Œå³ä½¿ä¸¤ä¸ªç»“ç‚¹çš„LCAç›¸èšå¾ˆè¿‘ï¼Œä»ç„¶éœ€è¦å›æº¯åˆ°æ ¹ç»“ç‚¹è®¡ç®—ç»“ç‚¹çš„é«˜åº¦ã€‚ </p>
<p>è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œå…¶æ—¶é—´å¤æ‚åº¦ä»…å–å†³äºç›®æ ‡ç»“ç‚¹ä¸LCAçš„è·ç¦»ã€‚</p>
<p>ä¹‹å‰çš„é¢˜ç›®å› ä¸ºæ²¡æ³•å¿«é€Ÿåœ°æŸ¥æ‰¾å·²è®¿é—®çš„ç»“ç‚¹ï¼Œæ‰€ä»¥éœ€è¦è®°å½•ç»“ç‚¹çš„é«˜åº¦ã€‚æœ‰äº†hashtableåï¼Œå¯ä»¥åœ¨$O(1)$çš„æ—¶é—´å†…æŸ¥æ‰¾å·²è®¿é—®å…ƒç´ .  å› æ­¤åœ¨å‘ä¸Šè®¿é—®çš„åŒæ—¶è®°å½•å†å²ä¿¡æ¯, ç”¨setåšæŸ¥æ‰¾.</p>
<div class="highlight"><pre><span></span><code><span class="n">BinaryTreeNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">Lca</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">BinaryTreeNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">node0</span><span class="p">,</span>
<span class="w">                         </span><span class="k">const</span><span class="w"> </span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">BinaryTreeNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">node1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// TODO - you fill in here.</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">BinaryTreeNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*&gt;</span><span class="w"> </span><span class="n">node_set</span><span class="p">;</span>
<span class="w">  </span><span class="n">BinaryTreeNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">p0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node0</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span><span class="w"> </span><span class="o">*</span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node1</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">p0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node_set</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">p0</span><span class="p">);</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iter</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">node_set</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">iter</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="n">node_set</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">p0</span><span class="p">);</span>
<span class="w">      </span><span class="n">p0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p0</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>

<span class="w">      </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node_set</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iter</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">node_set</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">iter</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="n">node_set</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>
<span class="w">      </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="o">*</span><span class="n">residual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p0</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">p0</span><span class="p">;</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">residual</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node_set</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">residual</span><span class="p">);</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iter</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">node_set</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">iter</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="n">residual</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">residual</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3>Find the nearest repeated entries in an array</h3>
<p>æ— é¢˜</p>
<h3>Find the smallest subarray covering all values</h3>
<p>When you type keywords in a search engine , the search engine will return results , and each result contains a digest of the web page , i .e. , a highlighting within that page of the keywords that you searched for. For example , a search for the keywords " Union " and " save " on a page with the text of the Emancipation Proclamation should return the result shown in Figure 13.1.</p>
<p>Write a program which takes an array of strings and a set of strings , and return the indices of the starting and ending index of a shortest subarray of the given array that " covers " the set , i .e. , contains all strings in the set.</p>
<p>æœ´ç´ çš„æƒ³æ³•å°±æ˜¯æ‰¾åˆ°æ‰€æœ‰çš„subarray, å»æ¯”å¯¹æ˜¯å¦æ»¡è¶³è¦æ±‚, æ—¶é—´å¤æ‚åº¦åº”è¯¥æ˜¯$O(n^3)$.</p>
<p>é€šè¿‡ä½¿ç”¨hashtableèƒ½å¤Ÿé™ä½æ¯”å¯¹æ—¶çš„æ—¶é—´å¤æ‚åº¦,å°†å…¶é™ä¸º$O(n^2)$.</p>
<p>å®é™…ä¸Š, è€ƒè™‘åˆ°è¿™ä¸ªé—®é¢˜çš„ç‰¹æ€§, æ—¶é—´å¤æ‚åº¦å¯ä»¥æ›´è¿›ä¸€æ­¥é™ä½ä¸º$O(n)$. subarrayå†…æœ‰æ•ˆçš„é•¿åº¦å°±æ˜¯keywordçš„æ•°é‡, æŸ¥æ‰¾çš„è¿‡ç¨‹å¯ä»¥è§†ä¸ºåœ¨paragraphä¸Šçš„ä¸€ä¸ªå˜é•¿æ»‘çª—æŸ¥æ‰¾.</p>
<p>å‡è®¾å½“å‰å·²ç»æ‰¾åˆ°ä¸€ä¸ªsubarray, é‚£ä¹ˆæ¥ä¸‹æ¥çš„æŸ¥æ‰¾åªä¼šå‘å³è¿›è¡Œ, è€Œä¸å¿…å†è€ƒè™‘å‰é¢çš„ç»„åˆ. æ¯”å¦‚å°†left idxè°ƒæ•´åˆ°ä¸‹ä¸€ä¸ªå…³é”®è¯çš„ä½ç½®, å°†æ»‘çª—å‘å³æ»‘åŠ¨.</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">Subarray</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Subarray</span><span class="w"> </span><span class="nf">FindSmallestSubarrayCoveringSet</span><span class="p">(</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">paragraph</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">keywords</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// TODO - you fill in here.</span>
<span class="w">  </span><span class="c1">// è®°å½•å½“å‰coverçš„å…³é”®å­—</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">keywords_to_cover</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">k</span><span class="o">:</span><span class="w"> </span><span class="n">keywords</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="o">++</span><span class="n">keywords_to_cover</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">remain_to_cover</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">keywords_to_cover</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

<span class="w">  </span><span class="n">Subarray</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">};</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">paragraph</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">r_word</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">paragraph</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
<span class="w">      </span><span class="c1">//keywords ä¸­çš„åŒä¸€ä¸ªå•è¯å¯èƒ½ä¼šåœ¨paragraphä¸­å‡ºç°å¤šæ¬¡</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">keywords</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">r_word</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">--</span><span class="n">keywords_to_cover</span><span class="p">[</span><span class="n">r_word</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="o">--</span><span class="n">remain_to_cover</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="c1">// remain_to_cover == 0 æ„å‘³ç€å½“å‰å·²ç»æ‰¾åˆ°ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„åŒºé—´ï¼Œå°†leftå³ç§»è‡³ä¸‹ä¸€ä¸ªå…³é”®è¯ä½ç½®ã€‚</span>
<span class="w">      </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">remain_to_cover</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">start</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">end</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">start</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">};</span>
<span class="w">          </span><span class="p">}</span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">keywords</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">paragraph</span><span class="p">[</span><span class="n">left</span><span class="p">])</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">++</span><span class="n">keywords_to_cover</span><span class="p">[</span><span class="n">paragraph</span><span class="p">[</span><span class="n">left</span><span class="p">]]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">              </span><span class="o">++</span><span class="n">remain_to_cover</span><span class="p">;</span>
<span class="w">          </span><span class="p">}</span>
<span class="w">          </span><span class="o">++</span><span class="n">left</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3>Find smallest subarray sequentially covering all values</h3>
<p>In Problem 13.7 on Page 216 we did not differentiate between the order in which</p>
<p>keywords appeared . If the digest has to include the keywords in the order in which they appear in the search textbox , we may get a different digest . For example , for the search keywords " Union " and " save " , in that order , the digest would be " Union , and is not either to save " .</p>
<p>Write a program that takes two arrays of strings , and return the indices of the start ing and ending index of a shortest subarray of the first array ( the " paragraph " array ) that " sequentially covers " , i .e. , contains all the strings in the second array ( the " keywords " array ) , in the order in which they appear in the keywords array . You can assume all keywords are distinct. For example , let the paragraph array be ( apple , banana , cat , apple ) , and the keywords array be ( banana , apple ) . The para graph subarray starting at index 0 and ending at index 1 does not fulfill the specification , even though it contains all the keywords , since they do not appear in the specified order. On the other hand , the subarray starting at index 1 and ending at index 3 does fulfill the specification .</p>
<p>Hint: For each index in the paragraph array , compute the shortest subarray ending at that index which fulfills the specification .</p>
<p>æ„Ÿè§‰è¿™ä¸ªåšæ³•æœ‰ç‚¹åƒDPï¼Œä½†æ˜¯ç›®å‰åˆä¸å¤ªèƒ½ç¡®å®š...</p>
<p>è·Ÿå‰ä¸€é¢˜æœ‰äº›ç›¸ä¼¼ï¼Œè¿™é‡Œå¤šäº†é¡ºåºçš„è¦æ±‚ã€‚éœ€è¦ä¸€ä¸ªtableè®°å½•keywordçš„åæ ‡ï¼Œç”¨äºè¡¨ç¤ºå…¶å‡ºç°çš„é¡ºåºã€‚è¿˜éœ€è¦è®¾è®¡ä¸€ä¸ªtableç”¨äºè®°å½•æŸä¸ªkeywordä¸Šæ¬¡å‡ºç°çš„ä½ç½®åŠä»¥è¯¥å…³é”®å­—ä¸ºç»“å°¾çš„subarrayçš„é•¿åº¦ã€‚</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">Subarray</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Represent subarray by starting and ending indices, inclusive.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Subarray</span><span class="w"> </span><span class="nf">FindSmallestSequentiallyCoveringSubset</span><span class="p">(</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">paragraph</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">keywords</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// TODO - you fill in here.</span>
<span class="w">  </span><span class="c1">// è®°å½•keywordçš„ä½ç½®</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">keyword_to_idx</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">keywords</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="c1">//      keyword_to_idx[keywords[i]] = i;</span>
<span class="w">      </span><span class="n">keyword_to_idx</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">keywords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// å°‘æ‰“ä¸€ä¸ª,  è°ƒäº†åŠå¤©...</span>
<span class="w">  </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">key_latest_occurrence</span><span class="p">(</span><span class="n">keywords</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="mi">-1</span><span class="p">);</span>

<span class="w">  </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">shortest_subarray</span><span class="p">(</span><span class="n">keywords</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">());</span>
<span class="w">  </span><span class="n">Subarray</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">};</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">shortest_array_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">paragraph</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">keyword_to_idx</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">paragraph</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="kt">int</span><span class="w"> </span><span class="n">key_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">keyword_to_idx</span><span class="p">[</span><span class="n">paragraph</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">key_idx</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="c1">// ç¬¬ä¸€ä¸ªkeyword</span>
<span class="w">              </span><span class="n">shortest_subarray</span><span class="p">[</span><span class="n">key_idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">          </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">shortest_subarray</span><span class="p">[</span><span class="n">key_idx</span><span class="mi">-1</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>

<span class="w">              </span><span class="n">shortest_subarray</span><span class="p">[</span><span class="n">key_idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shortest_subarray</span><span class="p">[</span><span class="n">key_idx</span><span class="mi">-1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">key_latest_occurrence</span><span class="p">[</span><span class="n">key_idx</span><span class="mi">-1</span><span class="p">];</span>
<span class="w">          </span><span class="p">}</span>
<span class="w">          </span><span class="n">key_latest_occurrence</span><span class="p">[</span><span class="n">key_idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>

<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">key_idx</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">keywords</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">shortest_array_len</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">shortest_subarray</span><span class="p">.</span><span class="n">back</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="n">shortest_array_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shortest_subarray</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
<span class="w">              </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">shortest_subarray</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">};</span>
<span class="w">          </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3>Find the longest subarray with distinct entries</h3>
<p>Write a program that takes an array and returns the length of a longest subarray with the property that all its elements are distinct. For example , if the array is <f,s,f,e,t,w,e,n,w,e>then a longest subarray all of whose elements are distinct is <s, f, e, t, w></p>
<p>Hint: What should you do if the subarray from indices i to j satisfies the property , but the subarray from i to j + 1 does not?</p>
<p>è¿™é¢˜å¾ˆåƒä¹‹å‰çš„Find the smallest subarray covering all valuesï¼Œè¦ä½¿ç”¨å˜é•¿æ»‘åŠ¨çª—å£ï¼ˆæˆ–è€…è¯´æ˜¯åŒæŒ‡é’ˆï¼‰ã€‚</p>
<p>å‡è®¾å½“å‰æ»‘åŠ¨çª—å£ä¸­æ— é‡å¤çš„å…ƒç´ ï¼Œå½“è¦å¤„ç†ä¸‹ä¸€ä¸ªå…ƒç´ aæ—¶ï¼Œå¦‚æœè¯¥å…ƒç´ åœ¨çª—å£ä¸­ä¸å­˜åœ¨ï¼Œç›´æ¥å°†å…¶åŠ å…¥çª—å£ã€‚å¦‚æœè¿™ä¸ªå…ƒç´ å­˜åœ¨è¿‡ï¼Œé‚£ä¹ˆéœ€è¦æ”¶ç¼©çª—å£çš„å·¦ä¾§ã€‚ å·¦ä¾§éœ€è¦å‘å³æ»‘åŠ¨åˆ°å·²ç»å‡ºç°çš„açš„å³ä¾§ï¼Œè¿™æ ·çª—å£ä¸­åˆä¸ä¼šåŒ…å«é‡å¤çš„å…ƒç´ äº†ã€‚</p>
<p>åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­éœ€è¦è®°å½•å…ƒç´ æ›¾ç»å‡ºç°è¿‡çš„ä½ç½®ã€‚</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">LongestSubarrayWithDistinctEntries</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// TODO - you fill in here.</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">last_appearance</span><span class="p">;</span><span class="w"> </span><span class="c1">//è®°å½•å…ƒç´ ä¸Šæ¬¡å‡ºç°çš„ä½ç½®</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">longest_array_start_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">insert_ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">last_appearance</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">i</span><span class="p">});</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">insert_ret</span><span class="p">.</span><span class="n">second</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// æ’å…¥ä¸æˆåŠŸ, è¯´æ˜A[i]ä¹‹å‰å‡ºç°è¿‡</span>
<span class="w">          </span><span class="kt">int</span><span class="w"> </span><span class="n">prev_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">insert_ret</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">prev_idx</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">longest_array_start_idx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// A[i] åœ¨æ»‘çª—å†…</span>
<span class="w">              </span><span class="n">longest_array_start_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev_idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">          </span><span class="p">}</span>
<span class="w">          </span><span class="n">insert_ret</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="c1">// æ›´æ–°ä½ç½®</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">longest_array_start_idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3>Find the length of a longest contained interval</h3>
<p>Write a program which takes as input a set of integers represented by an array , and returns the size of a largest subset of integers in the array having the property that if two integers are in the subset , then so are all integers between them. For example , if the input is ( 3 , - 2 , 7 , 9, 8, 1 , 2 , 0 , - 1 , 5 , 8 ) , the largest such subset is { - 2 ,- 1 , 0 , 1 , 2 , 3 ) , so you should return 6.</p>
<p>Hint Do you really need a total ordering on the input ?</p>
<p>è¦æ‰¾åˆ°ä¸€ä¸ªåŒ…å«è¿ç»­åŒºé—´å†…æ‰€æœ‰æ•´æ•°å€¼çš„é›†åˆã€‚ä¹‹å‰çš„æ»‘çª—æ³•æ²¡æ³•ç›´æ¥å¥—ç”¨åˆ°è¿™é‡Œï¼Œ å› ä¸ºå…ƒç´ å¤„åœ¨ä¸åŒçš„ä½ç½®å¹¶ä¸å½±å“æœ€ç»ˆçš„ç»“æœã€‚</p>
<p>å¯¹å…ƒç´ ç›´æ¥è¿›è¡Œæ’åºä¹Ÿæ˜¯å¯ä»¥çš„ï¼Œåªæ˜¯æ²¡å¤ªå¿…è¦ï¼Œè¿™é‡Œå¹¶ä¸éœ€è¦å…ƒç´ çš„é¡ºåºä¿¡æ¯ã€‚</p>
<p>ä¸ºäº†å¯¹å…ƒç´ è¿›è¡Œå¿«é€ŸæŸ¥æ‰¾ï¼Œå°†å…ƒç´ å…¨éƒ¨ä¿æŒåˆ°setä¸­ã€‚ç„¶åæ¯æ¬¡é€‰æ‹©ä¸€ä¸ªå…ƒç´ ï¼Œå‘ä¸Šå‘ä¸‹æ‰©å¼ ï¼Œå°†è®¿é—®è¿‡çš„å…ƒç´ ä»setä¸­å‰”é™¤(å¦‚æœæ˜¯è¿ç»­åŒºé—´ï¼Œåœ¨æ‰©å¼ çš„è¿‡ç¨‹ä¸­ä¸€å®šä¼šè¢«è®¿é—®åˆ°)ã€‚</p>
<p>è¿™æ ·ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º$O(n)$ã€‚</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">LongestContainedRange</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// TODO - you fill in here.</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">filter</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">filter</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">c_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">filter</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="w">      </span><span class="n">filter</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">c_val</span><span class="p">);</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">c_length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">bias</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">      </span><span class="k">while</span><span class="p">(</span><span class="n">filter</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">c_val</span><span class="o">+</span><span class="n">bias</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">filter</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">c_val</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bias</span><span class="p">);</span><span class="w"> </span><span class="c1">// å‰”é™¤å·²ç»è®¿é—®è¿‡çš„å…ƒç´ </span>
<span class="w">          </span><span class="o">++</span><span class="n">bias</span><span class="p">;</span>
<span class="w">          </span><span class="o">++</span><span class="n">c_length</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="n">bias</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">      </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">filter</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">c_val</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bias</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">filter</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">c_val</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bias</span><span class="p">);</span>
<span class="w">          </span><span class="o">--</span><span class="n">bias</span><span class="p">;</span>
<span class="w">          </span><span class="o">++</span><span class="n">c_length</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="n">c_length</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3>Compute all string decompositions</h3>
<p>This concerned taking a string ( the " sentence " string ) and a set of strings ( the " words " ) , and finding the substrings of the sentence which are the concatenation of all the words ( in any order ) . For example , if the sentence string is " amanaplanacanal " and the set of words is { " can " , " apl " , " ana " }, " aplanacan " is a substring of the sentence that is the concatenation of all words.</p>
<p>Write as a program which takes input a string ( the " sentence " ) and an array of strings ( the " words " ) , and returns the starting indices of substrings of the sentence string which are the concatenation of all the strings in the words array . Each string must appear exactly once , and their ordering is immaterial. Assume all strings in the words array have equal length . It is possible for the words array to contain duplicates .</p>
<p>Hint: Exploit the fact that the words have the same length .</p>
<p>è¦åœ¨stringä¸­æ‰¾åˆ°ç”±wordsä»»æ„é¡ºåºç»„æˆçš„substringï¼Œ è¿”å›substringçš„èµ·å§‹ä½ç½®ã€‚</p>
<p>é¢˜ç›®ä¸­ç»™å‡ºäº†wordså…·æœ‰ç›¸åŒçš„é•¿åº¦ï¼Œå°±é¿å…äº†åœ¨stringä¸­è¯•æ¢åˆç†çš„wordã€‚</p>
<p>æ–¹æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º$O(Nmn)$. Næ˜¯stringçš„é•¿åº¦, mæ˜¯å•è¯çš„æ•°é‡,næ˜¯å•è¯çš„é•¿åº¦.</p>
<div class="highlight"><pre><span></span><code><span class="kt">bool</span><span class="w"> </span><span class="nf">FindAllSubstringsHelper</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">word_cnt</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">st_idx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">word_len</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num_words</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">nb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st_idx</span><span class="p">;</span><span class="w"> </span><span class="n">nb</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_words</span><span class="p">;)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">string</span><span class="w"> </span><span class="n">c_sub</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">word_len</span><span class="p">);</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">word_cnt</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">c_sub</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">word_cnt</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">//ä¸åŒ¹é…</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">--</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// å‡ºç°è¿‡å¤šæ¬¡</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="o">++</span><span class="n">nb</span><span class="p">;</span>
<span class="w">        </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st_idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">nb</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">word_len</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">FindAllSubstrings</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">words</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// TODO - you fill in here.</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">word_cnt</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">each</span><span class="o">:</span><span class="w"> </span><span class="n">words</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="o">++</span><span class="n">word_cnt</span><span class="p">[</span><span class="n">each</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">word_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
<span class="w">  </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// ä¸‹é¢çš„æ¡ä»¶æ˜¯ &lt;=</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">word_len</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">words</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">FindAllSubstringsHelper</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">word_cnt</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">word_len</span><span class="p">,</span><span class="w"> </span><span class="n">words</span><span class="p">.</span><span class="n">size</span><span class="p">()))</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">ret</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3>Test the Collatz conjecture</h3>
<p>The Collatz conjecture is the following : Take any natural number. If it is odd , triple it and add one ; if it is even , halve it . Repeat the process indefinitely . No matter what number you begin with , you will eventually arrive at 1 .</p>
<p>As an example , if we start with 11 we get the sequence 11 , 34 , 17 , 52 , 26 , 13 , 40 , 20 , 10 , 5 , 16 , 8, 4 , 2 , 1 . Despite intense efforts , the Collatz conjecture has not been proved or disproved .</p>
<p>Suppose you were given the task of checking the Collatz conjecture for the first billion integers . A direct approach would be to compute the convergence sequence for each number in this set.</p>
<p>Test the Collatz conjecture for the first n positive integers</p>
<p>Hint How would you efficiently check the conjecture for n assuming it holds for all m &lt; n?</p>
<p>ä¹‹å‰åœ¨leetcodeä¸Šè§è¿‡æœ‰ç±»ä¼¼çš„é¢˜ç›®ï¼Œç›´æ¥åˆ©ç”¨æ•°å­¦å®šç†çš„çœŸä¼ªè¿”å›ç»“æœã€‚å¯¹äºè¿™é¢˜ä¹Ÿæ˜¯ç±»ä¼¼çš„ï¼Œæ—¢ç„¶è¿™ä¸ªå®šç†æ²¡æœ‰è¢«è¯ä¼ªï¼Œé‚£ä¹ˆå¯¹äºç›®å‰å·²çŸ¥çš„æ•°è‚¯å®šéƒ½æ˜¯å¯¹çš„ï¼Œç›´æ¥è¿”å›trueå°±å¥½äº†ã€‚</p>
<div class="highlight"><pre><span></span><code><span class="kt">bool</span><span class="w"> </span><span class="nf">TestCollatzConjecture</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// TODO - you fill in here.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>å¯¹äºä¸é‚£ä¹ˆæŠ–æœºçµçš„åšæ³•ï¼Œç”¨ä¸€ä¸ªsetå»æµ‹è¯•ç”Ÿæˆçš„åºåˆ—æ˜¯å¦è¿›å…¥å¾ªç¯ï¼ŒåŒæ—¶æ•°å€¼ç±»å‹éœ€è¦æ”¹ä¸ºlongä»¥é¿å…ä¸Šæº¢ã€‚</p>
<p>æ—¶é—´å¤æ‚åº¦è‡ªç„¶æ˜¯æ²¡æ³•åˆ†æäº†ğŸ’‡</p>
<div class="highlight"><pre><span></span><code><span class="kt">bool</span><span class="w"> </span><span class="nf">TestCollatzConjecture</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// TODO - you fill in here.</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span><span class="w"> </span><span class="n">table</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kt">long</span><span class="w"> </span><span class="n">c_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span><span class="w"> </span><span class="n">search_path</span><span class="p">;</span>
<span class="w">      </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">c_val</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">table</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">c_val</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">table</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="c1">// å½“å‰åºåˆ—å·²ç»å­˜åœ¨è¿‡</span>
<span class="w">              </span><span class="k">break</span><span class="p">;</span>
<span class="w">          </span><span class="p">}</span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">search_path</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">c_val</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">search_path</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// åºåˆ—è¿›å…¥å¾ªç¯ï¼Œ è¯ä¼ª</span>
<span class="w">          </span><span class="p">}</span>
<span class="w">          </span><span class="n">search_path</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">c_val</span><span class="p">);</span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">c_val</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="n">c_val</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">          </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">              </span><span class="n">c_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c_val</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">          </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="n">table</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">search_path</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">search_path</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="w"> </span><span class="c1">//æ›´æ–°æœç´¢åºåˆ—</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
    </div><!-- /.entry-content -->


  </article>


</section>

<div id="comments">
  <h2 style="margin-top: 0.1rem;">Comments !</h2>
  <div id="gitalk-container"></div>
</div>
<script>
  var gitalk = new Gitalk({
    clientID: '4dfbf5aad180623dc634',
    clientSecret: '4c7167883746062103d9dbc2ec8b1ddfd6780d58',
    repo: 'steermomo.github.io',
    owner: 'steermomo',
    admin: ['steermomo'],
    id: location.pathname,      // Ensure uniqueness and length less than 50
    distractionFreeMode: false,  // Facebook-like distraction free mode
    createIssueManually: true,
  })
  gitalk.render('gitalk-container')
</script>
        <section id="extras" class="body">
        </section><!-- /#extras -->
<footer id="contentinfo" class="body">
  <address id="about" class="vcard body">
    Copyright Â© 2024
    </br>
    Proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a
      href="http://python.org">Python</a>.
  </address>

  <!-- /#about -->


</footer><!-- /#contentinfo -->



</body>

</html>